# INS TEMPO Online Data Model and API Structure

Hierarchical Catalog Structure of Tempo Online
The INS Tempo Online database is organized as a hierarchical catalog of statistical datasets. At the top level are broad themes labeled with letters [e.g. A. Statistica Socială, B. Statistica Economică, etc.](1). Each top-level theme contains nested categories and subcategories (usually numbered). For example, theme A includes category A.1 Populație și structură demografică, which further contains subcategories like 1. Populația rezidentă, 2. Populația după domiciliu, etc.[2][3]. These numeric codes (e.g. 10, 1010) represent context nodes in the hierarchy.
The hierarchy typically has 2–3 levels of nesting: thematic group (lettered), sub-theme (numbered), and possibly sub-category. The leaf nodes at the deepest level are the actual datasets (also called matrices). Each dataset is identified by a unique code (usually an alphanumeric code like POP105A, SOM101E, etc., rather than a purely numeric code). The INS API distinguishes between category nodes and leaf nodes: category nodes have child categories or datasets, whereas leaf nodes correspond to data tables. In the API’s JSON, a category node will have a childrenUrl of "context" (indicating more subnodes), while a leaf node has childrenUrl of "matrix"[4].
 • Discovery Endpoints: The Tempo API provides REST endpoints to navigate this hierarchy. The root endpoint GET /tempo-ins/context/ returns the list of top-level contexts (themes). Each context or category has a code and name, and can be queried for its children via GET /tempo-ins/context/{code}[5]. This returns a JSON list of sub-contexts or datasets under that node. For example, .../context/1 might list all category A.1 subcategories. When a node is a leaf (dataset), its context entry will indicate the childrenUrl: "matrix", and one can fetch the dataset metadata with GET /tempo-ins/matrix/{code}[5]. In summary, contexts → categories → datasets are traversed by calling the context endpoint with the appropriate code until reaching a leaf.
Example: Calling the API for theme A (code 1) returns major subcategories (A.1, A.2, etc.). Querying .../context/10 (which corresponds to A.1 Populație) yields its children like “1. Populația rezidentă”, “2. Populația după domiciliu”[3]. Those entries in turn have childrenUrl = "matrix", meaning they directly contain datasets. Fetching .../context/1010 would list the actual datasets under Populația rezidentă. Each dataset is then accessible via its matrix code (e.g. POP105A). This hierarchical design is reflected in the context JSON structure: each context node has a code, a name, optional parentCode, and a childrenUrl (either “context” or “matrix”) among other fields[6].
Datasets (Matrices) and their Multi-Dimensional Structure
An INS dataset (matrix) represents a multi-dimensional OLAP cube of statistical data. Each dataset (identified by a code like POP105A) comes with metadata and a set of dimensions. A GET /tempo-ins/matrix/{code} call returns a JSON object containing:
 • Ancestors: the hierarchy of categories above this dataset (for context).
 • Matrix name and metadata: e.g. matrixName (title of the dataset), definition (definitie), methodology (metodologie), last update date (ultimaActualizare), observations (observatii), data sources (surseDeDate), and responsible persons[7]. This provides context and documentation for the dataset’s content.
 • Periodicity: an array periodicitati indicating the time frequency of the data [e.g. ["Anuală"] for annual data, or ["Lunară"] for monthly](8).
 • Dimensions: a dimensionsMap list defining each dimension of the data cube. Each dimension has a label (name) and a code, and comes with a list of options or permissible values[9]. For example, a population dataset might have dimensions like “Sexe” (with options Male, Female, Total) or “Macroregiuni, regiuni de dezvoltare și județe” (with options for each region and county). Internally, each dimension entry includes a numeric dimCode and the list of options [each option has an nomItemId ID, a text label, an offset for ordering, and possibly a parentId if the options are hierarchical](10).
 • Details: a details object with flags and attributes describing the dataset’s structure. This includes boolean flags like nomJud or nomLoc indicating the presence of certain territorial dimensions, matTime indicating which dimension is time, and other fields described below.
Cube Structure: Each dataset is essentially a table with N dimensions plus a value measure. The dimensions correspond to characteristics by which the data can be broken down (e.g. time, geography, gender, etc.). The measure (usually a numerical value) is the statistic being reported (e.g. population count, unemployment rate, etc.). According to INS data, most datasets have between 3 and 6 dimensions, though a few have more[11]. For example, a simple dataset might have dimensions [Region, Time] and one measure, while a more complex demographic dataset might have [Age Group, Sex, Residence (Urban/Rural), County, Time] plus the value.
When retrieving data, the API will return records with one column per dimension and a final column for the value. The dimension labels from the metadata correspond to column headings. For instance, a dataset might output columns: “Varste si grupe de varsta”, “Sexe”, “Medii de rezidenta”, “Macroregiuni, regiuni de dezvoltare si judete”, “Perioade”, “UM: Numar persoane”, and then “Valoare” [the value](12). Each row is a specific combination of dimension values. In the example of POP105A (Resident Population), a query selecting Total (all ages), Masculin (male), Rural, Bihor county, and years 2016–2017 returns output like:
Varste si grupe de varsta = Total, Sexe = Masculin, Medii de rezidenta = Rural, Județ = Bihor, Perioade = Anul 2016, UM: Numar persoane = Număr persoane, Valoare = 144,439 [population](12).(Another row for 2017 with value 145,335 is also returned[13].)
This illustrates how each dimension contributes to identifying the data cell, and the value is the measured statistic.
Common Dimension Types in Tempo Datasets
Each dataset’s dimensions can be categorized into several types. Understanding these is key to mapping the Tempo data model to our relational model:

1. Temporal Dimension (Periods)
Time is a nearly universal dimension (except for a few one-off indicators). It appears as “Perioade” in Romanian. Depending on the dataset’s frequency, this dimension contains values like years or months. For annual data, options are labeled “Anul 2010”, “Anul 2011”, etc. For quarterly data, they might be “Trimestrul I 2019”, and for monthly “Luna Ianuarie 2020”, etc., all under the Perioade dimension. The dataset metadata’s periodicitati field explicitly tells the time granularity: e.g. ["Anuală"] for annual, ["Lunară"] for monthly[8]. Some datasets might list multiple periodicities if they have data in more than one frequency (though typically each dataset has a single frequency). The matTime attribute in the details indicates which dimension index corresponds to time[14][15].
Granularity covered: Tempo provides annual series for most indicators, many monthly series (especially economic indicators like prices, employment, etc.), and some quarterly series (e.g. GDP). There are also a few one-time or irregular series (like census data) that effectively have a time dimension with a single value (e.g. year 2011 for the census). When integrating, we need to handle the time dimension according to the dataset’s periodicity. For example, annual data will join on a year key, while monthly data will require year-month keys, etc. (Transparenta.eu will likely focus on annual data for ease, but the API supports finer granularity as needed.)
2. Territorial Dimensions (Geography)
Geographic breakdowns are critical in Tempo data. INS uses a hierarchical territorial classification. The key geographic levels in Romania are: national total, Macroregiuni (four large macro-regions), Regiuni de dezvoltare (eight development regions, NUTS2 level), Județe (41 counties + Bucharest, NUTS3), and Localități (communes, towns, and municipalities, i.e., LAU level units). Tempo datasets use different approaches to include these:
 • County-level datasets (no LAU detail): For many datasets, the finest geography is the county. In such cases, INS typically uses a single combined dimension named “Macroregiuni, regiuni de dezvoltare si judete”. This one dimension includes entries for “TOTAL” (national total), each Macroregion I–IV, each Development Region, and each County[16]. These options are structured hierarchically (each county belongs to a region and macroregion). In the JSON, each option has a parentId linking it to its higher aggregate. For example, Bihor county is under Regiunea Nord-Vest, which is under Macroregiunea Unu. In the options list, Macroregiunea Unu and Nord-Vest would have parentId = null or top-level, while Bihor might have parentId referencing the Nord-Vest option’s ID. This single dimension allows selection of any geographic level (the API returns data accordingly – e.g. if “Bihor” is selected, values are for that county; if “Regiunea NORD-VEST” is selected, the value is the aggregate for that region). Note: In output, usually the specific name appears; e.g. a row might show “Bihor” for that dimension. The JSON metadata flags matRegJ = true when such a regional/county combo dimension is present[15].
 • Locality-level datasets (commune/city data): Some datasets go down to the locality (UAT) level. In these cases, the API uses two separate dimensions for geography: one for county (Județ) and another for locality (Localitate). The county dimension is used to filter or group localities, and the locality dimension lists the actual towns/communes. For example, dataset POP107D (population by domicile) has a dimension for Județ and a dimension for Localități[17]. In the query interface, one would first choose one or more counties, and then select localities within those counties. The data output includes two columns: one for county and one for locality. A sample schema for a local-level dataset shows separate judete_nom_id and localitati_nom_id fields[17]. Each locality option is associated with a specific county (in the JSON, each locality’s parentId links to a county’s option ID). The metadata flags nomJud=true and nomLoc=true in such cases[15].
 • National-only datasets: A few datasets have no regional breakdown at all (e.g. a single national time series). In those cases, there is effectively no geographic dimension – the data is just one series (the API might omit a geo dimension or use a dummy “Total” dimension).
Mapping of Codes (SIRUTA): INS references localities using the official SIRUTA code system (SIRUTA = unique identifier for each administrative unit). In the Tempo API, locality names in the output include their SIRUTA code as a prefix. For example, a locality might appear as "38731 Ripiceni" in the data export, indicating the commune of Ripiceni with SIRUTA code 38731[18]. The INS Tempo interface shows locality names with codes for clarity, since many villages/towns share names. We can leverage this by parsing out the numeric code. In fact, the QTempo tool does exactly that – if a dataset’s matSiruta flag is 1 (meaning it includes SIRUTA in output), QTempo parses the locality string to separate the code and name[18]. For our integration, we will map these directly to SIRUTA codes in Transparenta’s database.
For counties and regions, INS typically does not prepend SIRUTA codes in the label (they are fewer and well-known names). The API provides an internal nomItemId for each county/region, but these are not standard codes. We will need to map county names to their official codes (SIRUTA or perhaps county ISO/NUTS codes). Each county does have a SIRUTA code (for the county administrative unit; e.g. Bihor county’s SIRUTA is BH code in SIRUTA might be “302” or similar code – we will verify exact values from an official SIRUTA list). We will prepare a mapping table of county names to SIRUTA codes manually or from INS’s SIRUTA registry (INS provides a SIRUTA reference file separately). This mapping is critical for linking INS data with our system’s local entities (UATs), so that, for example, “Bihor” in INS data is recognized via the same code as “Bihor” in our database.
(Transparenta.eu is concerned primarily with data at the UAT (commune/city) and county level, so ensuring the geographic keys line up (via SIRUTA) is essential. We will extract all locality entries and their codes from the Tempo metadata to build the mapping.)
3. Demographic and Classification Dimensions
Many datasets include additional breakdown dimensions beyond time and geography. These reflect categories like demographics or economic classifications. Common ones include:
 • Sex: Typically a dimension called “Sexe” with options Masculin, Feminin, and sometimes Total [both sexes](19). If present, Sexe is usually a small dimension with 2 or 3 options (male, female, total). The parentId may link Male and Female under Total, or Total might be a separate aggregate option.
 • Age Groups: Often labeled “Vârste și grupe de vârstă”. Options might include specific age ranges (e.g. 0-4, 5-9, ..., 85+ years) and totals. For example, a population dataset might allow selecting specific age groups or “Total” [all ages](20). These can be hierarchical (individual ages might roll up into broader age bands, etc., though typically INS provides pre-defined groups).
 • Urban/Rural Residence: “Medii de rezidență” with options Urban, Rural, Total. This is common in population and social statistics, separating data by population living in urban vs. rural areas[19]. For instance, population or birth/death stats are often broken out by residence environment.
 • Indicator Type or Unit of Measure: Some datasets bundle multiple related indicators or units in one matrix. In such cases, one dimension may represent the indicator or measure. Often this appears as “UM: …” (short for Unitate de Măsură – unit of measure). For example, in some datasets one might see a dimension “UM: Număr” or “UM: Numar persoane”, which might seem trivial (only one option). In the accidents dataset example, a dimension “UM: Număr” had a single option “Număr”[21], effectively just labeling the values as a count. However, in other cases this dimension can have multiple entries; e.g., an economic dataset might have “Number” vs “Percentage” or “RON” vs “Euro”, or a labor dataset might have “efective” (counts of persons) and “indice” (index value) as separate measure options. If multiple indicators are included, the dimension could be named after the category of indicators. INS sometimes opts to split such cases into separate matrices, but it’s something to watch for. The matUMSpec flag in metadata indicates if a special unit-of-measure dimension exists[22].
 • Economic Classifications: For datasets in economics, business, or labor, you may encounter classification dimensions:
 • CAEN (Rev.1 or Rev.2): CAEN is the Romanian business activity classification (similar to NACE). A dataset might have a dimension for economic activity sector. The INS metadata flags matCaen1 or matCaen2 if a dataset uses CAEN Rev.1 or Rev.2 codes[22]. For example, an employment dataset might break down employment by industry sectors (agriculture, manufacturing, etc.). These dimensions typically have many options (all the sections/divisions of CAEN), possibly hierarchical (sections containing divisions).
 • Occupational groups or Education levels: e.g. a labor force dataset might classify by occupation or by education attainment. These would appear as dimensions with labels like “Grupa ocupațională” or “Nivel de educație”, each with their respective categories.
 • Other examples: “Forme de proprietate” (ownership type: public vs private), “Tipuri de instituții” (e.g. school types), “Categorii de localități” (size class of localities), etc., depending on the subject matter of the dataset.
Each dimension in the JSON has a label describing it. Our integration will maintain a data dictionary of these dimension labels and their meaning. For instance, “Macroregiuni, regiuni de dezvoltare și județe” = territorial unit (national to county), Sexe = gender, UM = unit/measure, etc., so that we can map them to our schema or at least understand them when selecting data.
Mapping INS Territorial Codes to SIRUTA (Administrative Unit Codes)
To integrate with Transparenta’s relational data, we need to align the INS location identifiers with our own. SIRUTA is the standard coding for local administrative units in Romania, and Transparenta likely already uses SIRUTA codes for identifying communes, towns, and counties. The good news is that INS’s Tempo data largely provides SIRUTA codes for localities:
 • Localities: As mentioned, the locality names in Tempo outputs contain the numeric SIRUTA code. We will extract these by parsing the names (everything before the first space is the code). For example, "38731 Ripiceni" clearly yields SIRUTA 38731 for Ripiceni[18]. We will generate a mapping of all localities appearing in relevant datasets to their codes. The matSiruta flag in the dataset’s details is set to 1 when these codes are included[23] (most locality-level datasets have this true). Using the API, we could even request the data with matSiruta=1 to ensure the codes appear (the default output usually includes them anyway). Our plan is to leverage this: whenever we pull UAT-level data, we’ll capture the locality code from the string and use it as a key to join with Transparenta’s locality records.
 • Counties: INS does not prefix county names with codes in outputs (for example, it will output “Bihor” rather than “05 Bihor”). The internal nomItemId for Bihor (seen in metadata) is not equal to its SIRUTA; for instance, INS option ID for Bihor might be 3068[24], which is just an internal key. Therefore, we must map county names to SIRUTA manually. Each county’s SIRUTA code is well-known (INS has published the SIRUTA list – e.g., Alba = 001, Arad = 021, etc., though note SIRUTA codes for counties might be two or three digits in some representations). We will create a lookup table: County Name → SIRUTA Code. Similarly, Bucharest will be mapped (București has a distinct code in SIRUTA).
 • Regions and Macroregions: These are not primary keys in our database, but for completeness, if needed, we can map them to official codes (e.g., development regions have NUTS2 codes RO11–RO42, macroregions have NUTS1 codes RO1–RO4). INS doesn’t use those codes in output, just names (“MACROREGIUNEA UNU”, “Regiunea NORD-VEST”, etc.). If we need to reference regions, we could assign them codes or simply handle them as labels since Transparenta likely focuses on local/county data.
By establishing these mappings, any data pulled from Tempo can be linked by geographic code. For example, population of Ripiceni from INS (code 38731) will map directly to Ripiceni in our system via the same code. We will verify that INS’s locality codes match the official SIRUTA list (they should, since SIRUTA is maintained by INS). The double-check can be done by spot-comparing a few known localities.
(Worth noting: The QTempo QGIS plugin effectively does a similar mapping – it joins INS data with boundary shapefiles at the commune level. In their documentation, they highlight “join statistical data with administrative boundaries at the commune level”[25], which relies on the SIRUTA codes as the linking key in the background. This confirms our approach to use SIRUTA as the common key.)
Temporal Granularity and Periods in Tempo
Temporal data in Tempo comes in various granularities, which we must handle appropriately:
 • Annual data: Most socio-economic indicators (population, GDP annual, etc.) are reported yearly. In the API, the time dimension for these will list values as “Anul {Year}” for each year available. The periodicitati field in metadata will contain "Anuală" for such datasets[8]. For example, population figures might be given for each year (usually at a specific date, e.g., resident population as of July 1 each year, or domiciled population as of Jan 1 each year). Annual series are straightforward to integrate (year as an integer key). Note: Some “annual” datasets actually represent a specific date each year (like 1 January or 1 July); INS distinguishes these in the indicator definition, but they still treat the dimension as “year”. We should capture any such nuance in the meta definition or name (e.g., POP107D is population on Jan 1, annually).
 • Quarterly data: Some datasets (mostly economic, e.g., quarterly GDP, unemployment rate by quarter, etc.) have a quarterly frequency. periodicitati would include “Trimestrială”. The Perioade dimension in those cases will have entries like “Trim I 2020, Trim II 2020, …”. When integrating, we can represent quarter periods as e.g. 2020-Q1 keys or separate year and quarter fields. The detail matTime might indicate a code (perhaps 3 for quarterly – though not explicitly documented, possibly an internal enumeration).
 • Monthly data: Many indicators (inflation indices, monthly unemployment, etc.) are monthly (periodicitati = “Lunară”). The Perioade dimension will list month-year combinations (often as “Luna {MonthName YYYY}” in Romanian). These will have 12 entries per year (sometimes INS also provides YTD or averages, but typically just each month as separate entries under the dimension). For integration, we may need to convert these to a date or a Year-Month key.
 • Other frequencies: A few datasets might be semi-annual or weekly or daily, but these are rare in Tempo Online. For example, some price indices might be monthly and annual in one dataset, but generally, INS keeps separate datasets for separate frequencies rather than mixing them. The periodicitati array could list multiple values if a dataset has data in multiple frequencies, but in the metadata we’ve seen, usually it’s a single value array. We did not encounter explicit semiannual in the references, but we will remain aware if any appear.
 • Irregular or single-period data: Certain datasets might only have one period (e.g., a one-time survey or 2011 census results). They will technically have a time dimension with one value (e.g., “Anul 2011”), or sometimes INS might hard-code that into the indicator. For integration, those are effectively constant values with respect to time.
In all cases, the Perioade dimension is our source for the time index. We will likely standardize these in our database (e.g., store years as integer, months as date or YearMonth). The metadata’s ultimaActualizare field tells us the last data point’s date – useful for knowing data currency. And the periods available can be inferred either from the dimension options or sometimes described in observatii (notes).
For Transparenta.eu, which is likely using mostly annual data for simplicity (e.g., to compare population vs budgets per year), we might focus on annual series. However, if needed, the integration can handle quarterly/monthly if a specific indicator is needed (e.g., monthly unemployment if required).
(Side note: The dataset code often encodes frequency – e.g., codes ending in “A” often denote annual series, “L” or “M” might denote lunar (monthly) series, “T” for trimestrial, etc. For instance, POP105A is annual population, SOM101E might be monthly (E = “evidență lunară”?), POP107D – here D stood for “domiciliu” rather than frequency. So the suffix letter isn’t uniformly frequency; one should rely on periodicitati instead of guessing by code.)
Datasets with Local (UAT-level) Data vs. Higher-Level Only
A key objective is to identify which datasets contain commune/city level data (UAT level), as those are most relevant for Transparenta (which deals with local government units). The majority of INS Tempo datasets are at national or county level. Only a subset offer data down to each locality. We will enumerate those of interest:
 • Population by domicile – POP107D: This is a flagship dataset providing the resident population by legal domicile for every locality, annually (every January 1). This dataset has dimensions for sex, age group, etc., and includes each commune/city. We see in its schema an explicit Localități dimension[17], confirming it’s at UAT level. This is highly relevant (it gives population figures for every UAT, which can be used for per capita calculations, etc.). We will include both total population and breakdowns as needed.
 • Population by residence – POP105A (or similar code): The resident (actually living) population might only be given by county and up. INS uses the concept of “populație rezidentă” which is typically estimated at county level annually (except census years where locality detail exists). We need to verify if there is a locality-level resident population dataset. Likely POP107D (domicile) is the main local population source, whereas POP105A (residence) is at county level. For our purposes, domicile population is acceptable as a close proxy, and is official for administrative population counts.
 • Vital statistics (births, deaths): These are often at county level. It’s unlikely that Tempo provides births/deaths by each locality (privacy issues for small localities). So these are probably county-only.
 • Migration statistics: Usually county or regional level (e.g., inter-county migration flows might not be at locality detail publicly).
 • Education: Number of schools, students, teachers – mostly at county level in Tempo. Some specific data (like school infrastructure) could be local, but typically aggregated by county.
 • Health: Hospital or doctor counts likely county level.
 • Economy/Labor:
 • Unemployment: The dataset SOM101E (registered unemployed) is at county level[26]. We haven’t seen evidence of unemployment by locality in Tempo (perhaps only large cities separately). So, likely no complete UAT coverage for unemployment in INS data.
 • Employment: Number of employees or firms – these are often available by county, and sometimes by locality for larger towns through other sources, but not comprehensively in Tempo for all communes.
 • Agriculture: Some agricultural indicators (like crop production) might be at county or even lower (agricultural census had commune data, but that might not be in Tempo; if it is, it’d be a large dataset).
 • Business statistics: Possibly counts of active enterprises by locality could be available (INS might have a dataset of firms by locality size, but uncertain if published).
 • Public utilities and infrastructure: This category (F. Utilități Publice și Administrarea Teritoriului) might contain local-level data such as: length of water networks, existence of sewage systems, etc., possibly by locality (since these are typically collected via questionnaires from each town hall). If Tempo includes those, they would be very relevant (e.g., number of localities with water supply, etc.). We should check if any dataset under category F has nomLoc = true. It’s likely – for example, number of public libraries by locality, or communal roads length by locality, etc., might exist.
 • Environment or others: Most environment data (pollution, protected areas) are not at commune level (mostly county or region).
In summary, the datasets with UAT granularity appear primarily in the population domain (and possibly a few in infrastructure). We will confirm by scanning the metadata: the nomLoc flag in the dataset details tells us if locality dimension exists[15]. Out of ~1,888 datasets, only a fraction have nomLoc=true. Based on an INS open data project, there are on the order of a few dozen such datasets. We will compile a list of those codes and titles. Key ones for Transparenta will include population (as noted), and we will look for any others like perhaps housing census data by locality, cultural institutions by locality, etc., that could enrich the platform.
For Transparenta.eu’s immediate needs, the most relevant indicators from Tempo at local level would be: Population (total and by demographic breakdowns, to contextualize budgets per capita, etc.), and potentially other socio-economic indicators if available per locality (like maybe number of registered enterprises or basic infrastructure presence). Since INS Tempo’s local data is limited, we might mostly rely on population. County-level data from Tempo could also be used for context (e.g., county GDP, county unemployment rate, etc., which can be shown for the county each locality belongs to). We will list out the datasets we find with nomLoc and evaluate their usefulness.
(As an example of listing UAT-level datasets: Populatia după domiciliu (POP107D) is one; possibly “Populația după domiciliu pe grupă de vârstă și sex, pe localități” might be a separate code; “Numărul de locuințe pe localități” (from census) could be another; “Suprafața intravilană pe localități” etc. We will prepare a comprehensive list in the deliverable, but these are hypothetical until verified.)
Data Dictionary of INS Tempo Fields and Entities
To integrate the INS data model, we have documented the fields and their meanings:
Context and Hierarchy Entities:
 • Context Node (Category): Represents a folder/category in the hierarchy. Fields: code (string identifier, numeric for categories), name (name of the category), parentCode (code of the parent category, or "0" if top-level), and childrenUrl (API path to children). If childrenUrl is "context", it means this node has subcategories; if "matrix", it means this node contains datasets[6]. There is also sometimes a comment (additional description). Example: { code: "1010", name: "1. Populația rezidentă", parentCode: "10", level: 2, childrenUrl: "matrix" } indicates a subcategory that will list datasets.
 • Leaf (Dataset) Node: In the context listing, a leaf is indicated by childrenUrl: "matrix". Its code will be something like "POP105A". Clicking or requesting that leads to the dataset metadata JSON.
Dataset (Matrix) Metadata:
 • matrixName: The human-readable title of the dataset (e.g. “Populația rezidentă la 1 iulie pe sexe și medii, pe județe”).
 • ancestors: A list of context objects (code and name) tracing the category path down to this dataset. This is useful for knowing its theme and subtheme.
 • periodicitati: An array of strings indicating the dataset’s time frequency [e.g. ["Anuală"], ["Lunară"], or both](8).
 • definitie: Definition or description of the indicator.
 • metodologie: Methodology notes.
 • observatii: Any observations or footnotes.
 • persoaneResponsabile: Contact persons for the data (names or departments).
 • surseDeDate: Data sources (each source has a name and type) – e.g., if data is collected by INS or provided by another institution, it may list it here.
 • ultimaActualizare: Date (DD-MM-YYYY) of last update. (In the import, they convert it to YYYY-MM-DD[27].)
 • intrerupereSerie / continuareSerie: If the time series was discontinued or continued from another code, info is provided here (often null; used if a series was split or changed definition).
 • dimensionsMap: List of Dimension objects. Each dimension has:
 • dimCode: an integer (1-based index of the dimension in this dataset).
 • label: the name of the dimension [e.g. "Sexe", "Perioade", "Macroregiuni, regiuni de dezvoltare si judete" etc.](28).
 • options: a list of Option entries for that dimension[29]. Each Option has:
 o nomItemId: an integer ID for the option (internal to INS; used in queries and in the CSV outputs as foreign keys).
 o label: the display label of the option (e.g. "Masculin", "Bihor", "Total 0-4 ani").
 o offset: an order index (starting at 1 for the first option, etc.) – typically corresponds to the natural ordering (e.g., Total =1, Macroregion I =2, etc.).
 o parentId: a reference to another option’s nomItemId if this option is a child in a hierarchy. For example, a county option will have parentId equal to the nomItemId of its region; a specific age might have parent = age group category, etc. If parentId is null, the option is top-level in that dimension[30].
We will compile these options into our data dictionary to understand code meanings. For instance, in one dataset’s dimension, nomItemId 21295 = "MACROREGIUNEA UNU", nomItemId 5726 = "Regiunea NORD-VEST", nomItemId 3068 = "Bihor"[16]. These IDs would be used in the CSV or query format (they appear in the pivot query results as numeric codes for efficiency).
 • details: This object contains metadata about the structure in a more coded form (mostly boolean flags or indices):
 • matMaxDim: Number of dimensions of the dataset (excluding the value). For example 6 for POP107D[31][32].
 • matTime: Type of time dimension – this seems to indicate what kind of time series it is. The values might correspond to annual/monthly (not explicitly documented in our sources, but it’s present). It might also indicate which dimension number is time (some sources treat it as dimension index). We see in code that they treat matTime as the index of the time dimension for marking it[33]. So if matTime = 5, dimension 5 is the time dimension.
 • nomJud: integer (often 0 or 1) – acts as a boolean flag whether a county dimension is present[15]. If nomJud > 0, it actually might hold the dimension index of the county dimension. For example, if nomLoc is also present, nomJud might be the index of Județ dimension. The scripts set nom_jud = bool(details['nomJud']) which indicates it’s used as boolean[34]. We interpret it simply as “Has county breakdown”.
 • nomLoc: similar for locality dimension[15] – indicates presence of a locality-level breakdown.
 • matRegJ: boolean flag for the combined region/judete dimension[35]. True if the dataset uses that single hierarchical geo dimension instead of separate county.
 • matSiruta: boolean – if true, the data output includes SIRUTA codes with local names [i.e., localities labeled with code](23). Practically, matSiruta=1 whenever nomLoc is true, because that’s when they need to disambiguate local names.
 • matUMSpec: boolean – true if there is a special unit-of-measure or indicator dimension (as discussed).
 • matCaen1 / matCaen2: booleans – true if the dataset is classified by CAEN Rev.1 or Rev.2 respectively[35].
 • matActive: boolean – indicates if the dataset is active (1) or has been discontinued (0). Most current datasets are active=1.
 • matViews, matDownloads: integers – counters of how many times the dataset was viewed/downloaded (not essential for our purposes, but present).
 • matCharge: an integer that possibly reflects a “complexity” or resource cost of the dataset (perhaps used internally to limit large queries). For example, high values might mean large datasets. We’ll note it but likely not use it directly.
In summary, the details flags give us a quick idea of the dataset’s dimensional structure [e.g., nomLoc=true means it’s at locality level; matRegJ=true means one geo dimension covers all regions/counties; matTime tells which dimension is time, etc.](15). We will utilize these to programmatically filter datasets (e.g., find all datasets with nomLoc true).
Data Querying: To actually extract data, after identifying a dataset and its dimensions, we must call the “pivot” or matrix endpoint with a POST request. Typically, the POST is sent to /tempo-ins/matrix/{code} (or possibly a /pivot endpoint as seen in QTempo’s code[36]). The POST body includes: a language (we’ll use "ro" for Romanian to get Romanian labels), a list arr of arrays specifying chosen options for each dimension, the matrixName or code, and a matrixDetails object which echoes some of the detail flags [nomLoc, nomJud, etc.](37)[38]. For example, a JSON payload might look like:
{  "language": "ro",  "arr": [    [ { "label": "Total", "nomItemId": 112, "offset": 1, "parentId": null } ],   // e.g., Total age group    [ { "label": "Masculin", "nomItemId": 113, "offset": 1, "parentId": null } ], // e.g., Male    ...    [ { "label": "Bihor", "nomItemId": 3068, "offset": 4, "parentId": 5726 } ],   // county Bihor    [ { "label": "Anul 2017", "nomItemId": 2017, "offset": 8, "parentId": null } ]  ],  "matrixCode": "POP105A",  "matrixDetails": { "nomJud": 0, "nomLoc": 0, "matRegJ": 1, "matTime": 5, ... }}
(This is illustrative; the actual nomItemId values and positions would come from the dimensionsMap. In practice, libraries like tempo.py construct this for you by selecting dimension options programmatically.)
Posting this will return the dataset values, typically in a CSV-like text format. The first line is the comma-separated column headers, and subsequent lines are the data rows[39]. For example, after posting a query, the response might start with:
"Varste si grupe de varsta, Sexe, Medii de rezidenta, Județe, Perioade, UM: Numar persoane, Valoare\nTotal, Masculin, Rural, Bihor, Anul 2016, Numar persoane, 144439\nTotal, Masculin, Rural, Bihor, Anul 2017, Numar persoane, 145335\n..."
The QTempo plugin actually uses a slightly different approach: it computes an encQuery (an encoded query string) and calls a pivot URL[36][40], but the underlying result is the same CSV text. We have the option to use direct JSON posts (as per Mark Vereș’s tempo.py approach) or replicate the encoded query as the web interface does. For clarity and control, we will use the direct JSON approach.
We will create wrappers to systematically query needed datasets. For each dataset: - Use context endpoints to find the dataset code (if we don’t already know it). - Fetch /matrix/{code} to get dimensions. - Construct the POST payload: for example, to get all localities in a county, we might iterate over locality options; or to get all data, INS might allow a special "Total" selection if available (but often you must explicitly select all options or a subset). - Retrieve the CSV output and parse it. The QTempo code provides a parsing example: it splits lines by comma and maps them to fields[39]. We can do similarly or use Python’s CSV.
Given that we only need certain indicators for Transparenta, we won’t be downloading everything (the entire Tempo has ~1.9k datasets). We will target specific ones, using this documented model as a guide.
Finally, we will produce the deliverables:
 1. Technical documentation – which is essentially this write-up explaining the data model [cube structure, dimensions, codes, etc.](41), so developers understand how to navigate and query the Tempo API.
 2. Territorial code mapping – a table mapping INS location identifiers to SIRUTA. For localities, this is basically extracting the code from the label (as demonstrated above with examples like Ripiceni[18]). For counties, we will use the county name to SIRUTA mapping. This table ensures any INS data row can be linked to the corresponding locality in Transparenta’s database.
 3. List of UAT-level datasets – we will enumerate datasets (by code and name) that contain nomLoc (locality) data. For each, we’ll note what it measures (e.g., population, maybe number of dwellings from census, etc.) and confirm its periodicity. This lets us know what local-level statistics are available to incorporate into Transparenta.
 4. List of relevant indicators – based on the above, we will highlight which specific statistical measures from Tempo are most useful for Transparenta’s mission of transparency. Likely the focus will be on population, demographics, and perhaps a few socio-economic indicators (any that exist at local level, or otherwise county-level that we can attach to localities indirectly). This will align INS data offerings with Transparenta’s needs.
By focusing on data extraction (and not on how Transparenta will display or use it), we ensure the integration groundwork is solid. In conclusion, INS Tempo provides a rich, hierarchical data source that we can navigate via its API. We now have a clear understanding of how to get from the high-level catalog down to the exact data points we need, and how to map them into our system.
Sources:
 • INS Tempo API documentation and Python client examples[41][5][4]
 • QTempo QGIS plugin (open-source) – understanding of spatial joins and code usage[25][18]
 • gov2.ro Tempo dump project – metadata schema [for flag meanings and counts](15)[30][17]
 • INS methodology papers (rTempo in R) and Transparenta requirements (for context).
￼
[1] [2] [3] [4] [5] [12] [13] [19] [20] [37] [38] [41] README.md
<https://github.com/mark-veres/tempo.py/blob/43a597bd6b4a59b332439364d4fe271c22e71b7d/README.md>
[6] [14] [40] _typing.py
<https://github.com/alecsandrei/QTempo/blob/71fa86b815116bf24b9cba047a20eb6dc5b4046c/qtempo/_typing.py>
[7] [9] [10] [28] [29] __init__.py
<https://github.com/mark-veres/tempo.py/blob/43a597bd6b4a59b332439364d4fe271c22e71b7d/tempo/__init__.py>
[8] [11] [15] [16] [17] [21] [22] [23] [24] [30] [31] [32] [35] DUCKDB_SPECS.md
<https://github.com/gov2-ro/tempo-ins-dump/blob/0dbc79ad0648830c734b3c4020c767d8c1596a25/docs/DUCKDB_SPECS.md>
[18] [33] [39] matrix.py
<https://github.com/alecsandrei/QTempo/blob/71fa86b815116bf24b9cba047a20eb6dc5b4046c/qtempo/matrix.py>
[25] GitHub - alecsandrei/QTempo: A QGIS plugin for accessing data from the TEMPO-Online statistical database
<https://github.com/alecsandrei/QTempo>
[26] [PDF] clustering of registered unemployment at territorial administrative ...
<https://ipe.ro/RePEc/WorkingPapers/wpconf141104.pdf>
[27] [34] 10-import-metadata.py
<https://github.com/gov2-ro/tempo-ins-dump/blob/0dbc79ad0648830c734b3c4020c767d8c1596a25/10-import-metadata.py>
[36] enums.py
<https://github.com/alecsandrei/QTempo/blob/71fa86b815116bf24b9cba047a20eb6dc5b4046c/qtempo/enums.py>
